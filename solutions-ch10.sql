-- 10.1
create schema beach;
-- 10.2
-- varchar should be replaced by text because there is no performance difference in Postgres.
create table beach.customers(
    first_name varchar(100),
    last_name varchar(100),
    email varchar(100),
    phone_number varchar(32),
    date_created date
);
-- 10.3
-- varchar should be replaced by text because there is no performance difference in Postgres.  decimal should be replaced by numeric with precision.
create table beach.equipment (
    type varchar(16),
    description varchar(255),
    replacement_cost decimal
);
-- 10.4
alter table beach.equipment
add column lost boolean;
-- 10.5
alter table beach.customers
add column customer_id bigint generated by default as identity primary key;
-- 10.6
alter table beach.equipment
add column equipment_id serial primary key;
-- 10.7
create table beach.rentals (
    rental_id bigint generated by default as identity primary key,
    customer_id bigint not null,
    equipment_id bigint not null,
    date_rented date,
    date_returned date
);
-- official solution is using a natural primary key
create table beach.rentals (
    customer_id bigint,
    equipment_id bigint,
    rental_date date,
    return_date date,
    primary key (customer_id, equipment_id, rental_date)
);
--
drop schema playground cascade;
create schema playground;
create table if not exists playground.users(
    email text,
    first_name text,
    last_name text,
    is_active boolean,
    constraint pk_users primary key(email)
);
create table if not exists playground.notes(
    note_id bigint generated by default as identity primary key,
    note text,
    user_email text references playground.users(email) on update cascade on delete cascade
);
create table if not exists playground.note_tags(
    note_id bigint,
    tag text,
    primary key(note_id, tag),
    foreign key(note_id) references playground.notes(note_id) on update cascade on delete cascade
);
-- 10.8
drop table if exists beach.rentals;
create table beach.rentals (
    customer_id bigint references beach.customers(customer_id) on delete cascade,
    equipment_id bigint references beach.equipment(equipment_id) on delete cascade,
    rental_date date,
    return_date date,
    primary key (customer_id, equipment_id, rental_date)
);
-- 10.9
create table beach.customers(
    customer_id bigint generated always as identity primary key,
    first_name text not null,
    last_name text not null,
    email text unique,
    phone_number text unique,
    create_date date not null default current_date,
    check (
        email is not null
        or phone_number is not null
    )
);
-- 10.10
create table beach.equipment (
    equipment_id bigserial primary key,
    item_type text not null,
    description text,
    missing boolean default false,
    replacment_cost numeric(7, 2) check(replacement_cost > 0)
);
-- 10.11
-- When using 'by default' user specified values for such a generated column take precedence over the system value on insert or update.  In the case of `generated always` the system values cannot be overriden very easily.
-- official solution is:
-- With BY DEFAULT, PostgreSQL will generate a unique value for the column on insert, but will also allow you to insert your own value if you want to manually take control. With ALWAYS, if you attempt to provide your own value for the column as part of the insert statement, you'll get an error.
-- 10.12
-- A foreign key based solution is fine since we do not need the additional validation logic DOMAIN provides.  Usually I would have used an enum but they're very hard to change if variants need to be modified.
-- https://www.commandprompt.com/blog/fk_check_enum_or_domain_that_is_the_question/
-- official solution is:
-- The approach I would take is to store the types in their own table with the type defined as the primary key. The main reason for preferring this approach is because it would be reasonable to expect new types of equipment to be added over time. When this happens, rather than having to alter constraints, drop the enum type and recreate, etc. and all the other complicated approaches, managing the types in their own table would be very easy with simple INSERT statements. We could also easily produce a list of all the different types available for rent, etc.
create table equipment_types (type text primary key);
-- 10.13
-- official solution is:
select count(*)
from beach.equipment
where item_type = 'Single Kayak'
    and missing = false
    and equipment_id not in (
        select equipment_id
        from beach.rentals
        where return_date is null
    );
-- 10.14
-- official solution is:
-- One approach could be to split out the equipment being rented in to its own table. So as shown below, the rental_details table would capture details about the items, and could contain multiple entries for each rental ID.
create table beach.rentals (
    rental_id bigserial primary key,
    customer_id bigint references beach.customers (customer_id),
    rental_date date,
    return_date date
);
create table beach.rental_details (
    rental_id bigint references beach.rentals (rental_id),
    equipment_id bigint references beach.equipment (equipment_id),
    primary key (rental_id, equipment_id)
);